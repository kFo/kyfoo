;; Syntax

; Tokens

id ::= (a..z, A..Z) *(U(a..z, A..Z, 0..9, '_'))
free ::= '\' id
integer ::= +(0..9) ?('e' +(0..9))
rational ::= *(0..9) '.' +(0..9) ?('e' +(0..9))
string ::= '"' *([printable]) '"'

; Expressions

primary-expr ::= id
               | free
               | integer
               | rational
               | string

ref-expr ::= '=' id
           | primary-expr

basic-expr ::= tuple
             | ref-expr

dot-expr ::= ?('.') +(basic-expr, '.')

apply-expr ::= +(dot-expr)

expr ::= apply-expr ?(':' expr)

tuple-open ::= '(' *(expr, ',') ')'
tuple-open-left ::= '(' *(expr, ',') ']'
tuple-open-right ::= '[' *(expr, ',') ')'
tuple-closed ::= '[' *(expr, ',') ']'
tuple-sym ::= ?(id) '<' *(expr, ',') '>'
tuple ::= tuple-open
        | tuple-open-left
        | tuple-open-right
        | tuple-closed
        | tuple-sym

scope ::= ind(>) *(expr, ind(=)) ind(<)
        | expr

; Declarations

import-decl ::= 'import' +(id, '.')

symbol ::= id ?('<', *(expr, ','), '>')

symbol-decl ::= symbol '=' expr

data-sum-decl ::= ':|' symbol
data-sum-ctor ::= symbol ?('(' *(id ':' expr, ',') ')')
data-sum-defn ::= ind(>) +(data-sum-ctor, ind(=)) ind(<)
data-sum ::= data-sum-decl ?(data-sum-defn)

data-prod-decl ::= ':&' symbol
data-prod-field ::= id ':' expr ?('=' expr)
data-prod-defn ::= ind(>) +(scope-data-prod, ind(=)) ind(<)
data-prod ::= data-prod-decl ?(data-prod-defn)

templ-decl ::= symbol
templ-defn ::= ind(>) +(scope-decl, ind(=)) ind(<)
templ ::= templ-decl templ-defn

proc-decl ::= '(' *(id ':' expr, ',') ')' ?('->' expr)
proc-defn ::= '=>' ind(>) +(scope-proc, ind(=)) ind(<)
            | '=>' expr
proc ::= proc-decl ?(proc-defn)

proc-templ ::= templ-decl proc-decl ?(proc-defn)

scope-decl ::= import-decl
             | proc
             | data-prod
             | data-sum
             | symbol-defn

scope-proc ::= scope-decl
             | expr

scope-data-prod ::= scope-decl
                  | data-prod-field

module ::= +(scope-decl, ind(=))

;; Semantics

Primary expressions (/primary-expr/) are sequences of program source that form 
the building blocks of a kyfoo program. They are the "atoms", if you will. 
Note that, except for the string expression, they do not contain spaces. In 
this regard they are similar to words of an english sentence, where words 
can be thought of as the "atoms" of a sentence. They come in the following 
varieties:

    /id/ is refers by name to an existing declaration.
    
    /free/ is a /id/ with a '\' prefix. Whereas an /id/ identifies an existing
    declaration, a /free/ declares a new sym-var declaration as part of a pattern.
    
    /integer/ is a base 10 integer number.
    
    /decimal/ is a base 10 rational number.
    
    /string/ is a sequence of printable text that would otherwise be interpreted
    as part of the program source, with the exception of escape characters.

Reference expressions (/ref-expr/) refer to the identity of a declaration rather
than its value.

Dot expressions (/dot-expr/) refer to member declarations of a declaration. As a 
failover dot-expr lowers into an apply-expr with the first two names reversed.

Tuple expressions (/tuple-expr/) are groups of expressions. Tuples come in the
following varieties:
    
    ( , ) is an /tuple-open/ tuple. They always flatten in their context.
    ( , ] is a /tuple-open-left/
    [ , ) is a /tuple-open-right/
    [ , ] is a /tuple-closed/
    
    indent(>) indent(=) indent(<) is an indent tuple (synonymous with scope). An
    indent is the number of spaces at the start of a source line. Every source 
    program starts with the notion of zero indent. indent(>) means the indent has 
    increased since the last line, indent(=) means the indent is the same as the 
    last line, and indent(<) means the indent has decreased. indent(<) must always 
    match a previously established indent, and there is an implicit indent(<)
    for every previous indent that is skipped. In this way, indent(>) always 
    conceptually matches with an indent(<).

Symbol tuples (/tuple-sym/) name a particular declaration. A symbol tuple must 
always begin with an identifier, which always maps directly to a symbol name. The 
remaining expressions are used as parameters for pattern matching to a specific 
symbol overload.

Apply expressions (/apply-expr/) combine other expressions to invoke a declaration.
They match first for procedures, unnamed and ctors, and then lower into tuple-sym 
expressions as failover. The first expression is denoted the subject and always
matches a templ-decl or data-prod-decl. When the subject does not start with an 
identifier it is flattened into the containing apply-expr.

Expressions (/expr/) are apply-expressions with an optional constraint expression.
Constraints are expressions that describe the values of another expression or
declaration are allowed.

Declarations
